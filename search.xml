<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[data转NSString的Encoding问题]]></title>
      <url>2016%2F12%2F14%2F26.%20data%E8%BD%ACNSString%E7%9A%84Encoding%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[data转NSString的Encoding问题在做安工助手这款App的时候需要抓取网页HTML，我想把抓取放到后台来进行，于是使用NSURLSessionDataTask，却发现了一个BUG，死活获取不到数据，不知道为什么。今天一步步排查，终于找到原因了，因为Encoding的问题 不完整代码： NSURLSessionDataTask *task = [_session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@"task = %@", [NSThread currentThread]); NSString *str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@"str = %@", str); dispatch_async(dispatch_get_main_queue(), ^&#123; _dataTextView.text = str; NSLog(@"_dataTextView %@", [NSThread currentThread]); &#125;); &#125;]; 设置断点后的结果是，data是有数据的，但str是没数据的，这我就很纳闷了，不可能啊，试了其他代码之后，终于想到，难道是encoding的问题？我果断把请求的URL换成百度，成功了…这真是个坑，我们在将网页的NSData转换为NSString，一定要看好网页原来是什么格式的 例如我这个网页的编码是GB2312 那么就应该需要响应的编码 NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);NSString *str = [[NSString alloc] initWithData:data encoding:enc]; 运行以后，正常。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ruby on rails学习]]></title>
      <url>2016%2F12%2F09%2F25.%20ruby%20on%20rails%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[ruby on rails学习（档案／资料夹 ：用途 ） app/ ： 包含你应用程式的 controllers、models、views。你要改的东西大多是这些。 config/ ： 设定应用程式的执行阶段规则、路由设定（routes）、资料库等等。 db/ ：显示你目前资料库的 schema（结构定义），以及资料库的 migrations。 public/ ：这是唯一一个资料夹会是放什么就出现什么的。如果你把档案放里面，server 会直接回传，不会经过 Rails 的处理。 app/assets/ ：你会要把图片、JavaScript、stylesheets (CSS) 还有其他静态档案放在里面。现代的 Rails 应用程式使用一种叫做 Assets Pipeline 的东西，把在这资料夹里面的所有 JavaScript 和 CSS 档合并成一个档案来加速。 rails new 还建立了其他很多东西。大概可以写一本书来讲，所以我们现在先无视它们。 new topics这些网页到底怎么建出来，又是如何连在一起的呢？Rails 的 scaffold 帮你处理好了。 我们来仔细瞧瞧 rails 帮我们建立的档案： app/models/topic.rb 这个档案里面有我们的 topic model 的程式码。如果你仔细看，他其实几乎是空白的。 对资料的新增、读取、更新、删除操作在 Rails 是内建的。 app/views/topics 这个资料夹里面有我们的 topics model 的 view 的程式码。 你刚刚使用的表单的程式码就放在这里面。Rails 会帮你建好这些档案作为 scaffold 的一部分。 如果你以前写过 HTML，这些程式你应该不陌生。 Rails 的 view 只是 HTML 加上一些用来显示资料库来的资料的程式。 app/views/topics/index.html.erb 这个程式是用在列出所有 topics 的页面。 index 是用来表示一个网站或网站的一部分的“预设”页面。当你打开 http://localhost:3000/topics 的时候，topics 的 index 页面会传送到你的电脑上。 app/views/topics/show.html.erb 是当你在 Listing topics 按一下 show 时会看到的页面。 app/views/topics/new.html.erb 是当你按一下 New Topic 时会看到的页面。 app/views/topics/edit.html.erb 是当你按一下 Edit 时会看到的页面。 app/views/topics/_form.html.erb 你或许注意到了，新增 topic 和编辑 topics 的页面长得很像。这是因为他们都使用了这个档案来显示表单。 这种档案称作 partial，因为他只有网页里面一部分的内容。Partial 的档名一定是底线开头的。 挑战题：你可以找到 partial 是在 new.html.erb 和 edit.html.erb 的哪一行程式被引用的吗？ app/controllers/topics_controller.rb 这称为 controller 档，Rails 自动透过 scaffold 产生的。 如果你打开来看，你会看到每一个 view ，除了 _form.html.erb 之外都对应到一个 method（开头是 def）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongod 使用]]></title>
      <url>2016%2F12%2F08%2F24.%20mongod-%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[mongod 使用进入Shell mongo 启动 mongod]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>2016%2F12%2F07%2FautoLayoutAndFrame%2F</url>
      <content type="text"><![CDATA[autoLayout(void)setNeedsUpdateConstraints- (void)updateConstraintsIfNeeded frame- (void)setNeedsLayout- (void)layoutIfNeeded - (void)layoutSubviews // 更改子view的布局]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[retainCount并不能返回正确的数值]]></title>
      <url>2016%2F12%2F07%2F22.%20retainCount%E5%B9%B6%E4%B8%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%95%B0%E5%80%BC%2F</url>
      <content type="text"><![CDATA[retainCount并不能返回正确的数值我想通过retainCount来理解引用计数，在网上搜了搜，看到了这个方法 相同意思的两行代码，却返回了不同的结果 NSDate *now = [NSDate date]; NSDate *nowinit = [[NSDate alloc] init]; NSLog(@"now = %@, retain count = %ld", now, CFGetRetainCount((__bridge CFTypeRef)(now))); NSLog(@"nowinit = %@, retain count = %ld", nowinit, CFGetRetainCount((__bridge CFTypeRef)(nowinit))); retainCount的值 [NSDate date]输出的结果是2 [[NSDate alloc] init]输出的结果是1 这让我大为不解，从结果来看，他们是完全相同的，不应该会是这样，如果不同的话，其他人也应该会指出的，但我没发现有人说出来。 我尝试Google了一下，Google上第一个就是 Cocoa中retainCount返回值不准的原因这个，看了之后我才发现，Apple也说了，这个东西不准，我干，既然不准，这个方法还存在干嘛。我有看到StackOverFlow上面的回答，他劝我们使用 Instruments 中的 Leaks 和 Zombies 来检测泄露的内存和僵尸对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Genymotion Android模拟器]]></title>
      <url>2016%2F11%2F28%2F21.%20Genymotion%20Android%E6%A8%A1%E6%8B%9F%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Genymotion Android模拟器想试试用Charles对AndroidApp 抓包，谁知道模拟器这么难调试 记录一下 Genymotion网络为(NAT) 用模拟器访问本机地址为 10.0.3.2 我的Charles代理端口为7777，所以就设置上了 Mac 上启用 Surge 后，虚拟机的「网络设置-代理」里填上对应的 IP 地址就可以让虚拟机也能走代理，如下图所示假定 Mac 里的代理设置是 127.0.0.1:6152，通过查看虚拟机的 IP 可以推断出 Mac 作为主机的 IP 是 10.211.55.2，代理设置里填写 10.211.55.2:6152 即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法学习第一节]]></title>
      <url>2016%2F11%2F26%2F20.%20%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%8A%82%2F</url>
      <content type="text"><![CDATA[Dynamic Connectivity(动态连通性)Question： How many connected components result after performing the following sequence of union operations on a set of 10 items? 1-2 3-4 5-6 7-8 7-9 2-8 0-5 1-9 Answer: 3 个人见解：这个问题是说，有几个连通的集合，比如1-2，说明1和2之间是连接的，那么1-2 和 2-8 说明1到8之间是连通状态，那么他们三个是一个集合，由此计算，总共有3个集合 Quick Find（快速查找、贪心算法）code: public class QuickFindUF &#123; private int[] id; public QuickFindUF(int N) &#123; id = new int[N]; for (int i = 0; i &lt; N; i++) // set id of each object to itself id[i] = i; &#125; public boolean connected(int p, int q) &#123; //check whether p and q are in the same component return id[p] == id[q]; &#125; public void union(int p, int q) &#123; // change all entries with id[p] to id[q] int pid = id[p]; int qid = id[q]; for (int i = 0; i &lt; id.length; i++) if (id[i] == pid) id[i] = qid; &#125;&#125; 将连接到的数字更改为相同数字 相同的数组元素就意味着连通 时间复杂度 缺点 时间复杂度太大 Quick Union把数组看作一组树，数组中每一项是它在树中的父节点 Question: Suppose that in a quick-union data structure on 10 elements that the id[] array is 0 9 6 5 4 2 61 0 5 What are the roots of 3 and 7, respectively? Answer: 6 and 6 The root of 3 is 6: 3-&gt;5-&gt;2-&gt;6 The root of 7 is 6: 7-&gt;1-&gt;9-&gt;5-&gt;2-&gt;6 和Quick Find的区别在于，是用相同根节点来表示数组中相同的元素，并且有利于合并。在合并树的时候，只需要改变一个值，比如把p这个树合并到q中，只需要更改id[9]的值为6即可，这就意味着9这个结点的根节点是6，这样其他值就无需更改，减少了操作 code: public class QuickUnionUF &#123; private int[] id; public QuickUnionUF(int N) &#123; id = new int[N]; for (int i = 0; i &lt; N; i++) id[i] = i; //set id of each to itself &#125; private int root(int i) &#123; // chase parent pointers until reach root while (i != id[i]) i = id[i]; return i; &#125; public boolean cinnected(int p, int q) &#123; //check if p and q have same root return root(p) == root(q); &#125; public void union(int p, int q) &#123; // change root of p to point to root of q int i = root(p); int j = root(q); id[j] = j; &#125;&#125; algorithm initialize union find quick-find N N 1 quick-union N N N to slow 在查找一个高度很高的树时，每一次都需要回溯整棵树，浪费时间，每一次查找都是对数组的一次遍历 Quick-Union Improvements在实现quick-union的时候执行一些操作避免得到很高的树，如果一个大树和小树合并，避免将大树放在下面，那将会导致更高的树 在带权算法中，总是将小的树放在下面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为什么要把插座变量声明为弱引用？]]></title>
      <url>2016%2F11%2F25%2F19.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E6%8F%92%E5%BA%A7%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[iOS上强引用循环的几处场景为什么要把插座变量声明为弱引用？将插座变量声明为弱引用是一个编程约定，当系统的可用内存偏少时，视图控制器会自动释放其视图并在之后需要显示时再创建。因此，视图控制器应该使用弱引用特性的插座变量指向view的子视图，以便在释放view时同时释放view的所有子视图 来自《iOSProgramming》4th edition 委托弱引用对象及其委托之间产生强引用循环。例如BNRHypnosisViewController是UITextfield对象的委托，而且UITextfield对象是BNRHypnosisViewController的强引用属性，如果UITextfield对象再对其委托保持强引用，就会在两者之间产生强引用循环，很容易造成内存泄露]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C属性声明的关键字]]></title>
      <url>2016%2F11%2F23%2F18.%20%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[Objective-C声明属性的关键字介绍readonly和readwritereadonly只有getter方法，没有setter方法，杜绝了从外部访问属性的可能，但是在本身也无法使用self调用方法 解决方法：把属性的声明写在.m文件中，可以避免外界的访问，也可以在本身使用self调用方法 默认是readwrite strong vs weak不同 引用计数+1 strong是强引用，属性声明时默认就是强引用 注意：强引用循环/循环引用现象说明：循环引用是指，两个对象之间相互强引用，导致无法被释放，造成内存泄露。一般是存在父子关系的时候容易发生这种现象，比如两个包类，其中背包里面拥有钱包。 // 来自《iOS编程》第四版// BNRItem.h@property (nonatomic, strong) BNRItem *containedItem;@property (nonatomic, strong) BNRItem *container;// BNRItem.m- (void)setContainedItem:(BNRItem *)containedItem &#123; _containedItem = containedItem; // 将item加入容纳它的BNRItem对象时， // 会将它的container实例变量指向容纳它的对象 self.containedItem.container = self;&#125;- (void)dealloc &#123; NSLog(@"Destroyed %@", self);&#125;// main.m#import &lt;Foundation/Foundation.h&gt;#import "BNRItem.h"#import "Person.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 创建一个NSMutableArray对象，并用items变量保存该对象的地址 NSMutableArray *items = [[NSMutableArray alloc] init]; BNRItem *backpack = [[BNRItem alloc] initWithItemName:@"Backpack"]; [items addObject:backpack]; BNRItem *calculator = [[BNRItem alloc] initWithItemName:@"Calculator"]; [items addObject:calculator]; backpack.containedItem = calculator; backpack = nil; calculator = nil; for (BNRItem *item in items) &#123; NSLog(@"%@", item); &#125; NSLog(@"Setting items to nil...."); items = nil; &#125; //此时输出结果是 /* 2016-11-24 13:50:44.023481 RandomItems[36837:2040846] Backpack () :Worth $0, recorded on 2016-11-24 05:50:44 +00002016-11-24 13:50:44.023586 RandomItems[36837:2040846] Calculator () :Worth $0, recorded on 2016-11-24 05:50:44 +00002016-11-24 13:50:44.023605 RandomItems[36837:2040846] Setting items to nil....Program ended with exit code: 0 */ 由于我们重写了dealloc方法，在对象即将被释放时，应该调用dealloc方法，这里并没有调用，说明这两个对象并没有正常释放。 首先确定父子关系，确定之后，让父对象拥有子对象，子对象不能拥有父对象，比如backpack是父对象，calculator是子对象，根据这个规则名，将backpack指向calculator(_containedItem)的指针保留为强引用，将calculator指向backpack(_container)的指针保留为弱引用。 @property (nonatomic, weak) BNRItem *container;//输出/* 2016-11-24 14:10:18.675480 RandomItems[37054:2053319] Backpack () :Worth $0, recorded on 2016-11-24 06:10:18 +00002016-11-24 14:10:18.675578 RandomItems[37054:2053319] Calculator () :Worth $0, recorded on 2016-11-24 06:10:18 +00002016-11-24 14:10:18.675595 RandomItems[37054:2053319] Setting items to nil....2016-11-24 14:10:18.675635 RandomItems[37054:2053319] Destroyed Backpack () :Worth $0, recorded on 2016-11-24 06:10:18 +00002016-11-24 14:10:18.675929 RandomItems[37054:2053319] Destroyed Calculator () :Worth $0, recorded on */ 比如背包和钱包是同一品牌的产品，我们用一个类来代替，类中有两个属性，(containedItem)一个是里面放了什么东西，(container)一个是被什么东西包含了，在把钱包放入背包后，背包的containedItem指向了钱包，而钱包的container指向了背包，就造成了循环引用，解决方法是，把钱包的指向改为弱引用。 strong vs assign不同 strong修饰OC对象 strong强引用，引用计数+1 assign修饰非OC对象 assign拷贝值，不做引用计数 assign可以用在非OC对象上吗？ 可以，但不会做引用计数+1 weak vs assign相同 可以修饰OC对象 不做强引用，引用计数不加1 不同 weak在对象释放时自动置为nil assign保留原始值，释放对象时不会置为nil（不安全）(unsafe_unretained) 场景：在对象被释放之后，weak会将对象置为nil，准确的说是对象的地址置为nil，而assign则不会，所以就有可能发生一种现象，如果对象被释放了，而assign修饰的对象的指针还在指向着那块内存地址，当其他对象使用了这块内存地址时，就容易发生冲突，基础类型不会发生这种情况，所以我们应该使用weak来修饰对象，用assign来修饰基础类型。 copy使用copy关键字声明属性，在使用过程中，内部会调用copyWithZone方法，重新生成一个新的不可变的类型并赋值返回，这样做的好处是，当拥有一个可变类型的子类来使用时，就可以避免可变类型的子类对象进行的反复修改，避免导致不可控现象。 举例说明 // main.m#import &lt;Foundation/Foundation.h&gt;#import "Person.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... NSMutableString *mutableString = [[NSMutableString alloc] init]; mutableString = [NSMutableString stringWithString:@"1234"]; Person *p1 = [[Person alloc] init]; p1.name = mutableString; NSLog(@"p1.name = %@ --&gt; %p", p1.name, p1.name); NSLog(@"mutableString = %@ --&gt; %p", mutableString, mutableString); NSLog(@"appendString之后"); [mutableString appendString:@"5"]; NSLog(@"p1.name = %@", p1.name); NSLog(@"mutableString = %@", mutableString); &#125; return 0;&#125;// 使用copy关键字声明的name// 输出/*2016-11-24 13:25:12.320037 copy[36455:2025654] p1.name = 1234 --&gt; 0x34333231452016-11-24 13:25:12.321110 copy[36455:2025654] mutableString = 1234 --&gt; 0x1003065a02016-11-24 13:25:12.321189 copy[36455:2025654] appendString之后2016-11-24 13:25:12.321433 copy[36455:2025654] p1.name = 12342016-11-24 13:25:12.321475 copy[36455:2025654] mutableString = 12345*/ 可以看到，在执行完毕p1.name = mutableString;之后，两个指针的地址就不同了，这就是因为重新生成了一个地址来指向p1.name，并且是不可变类型的。而mutableString还在那里。 缺点：频繁使用会造成内存的浪费，所以我们只在必要时使用 nonatomic vs atomic在iOS上我们用nonatomic，默认时atomic，所以我们要将其声明 说明，两者的区别是使用时保证线程安全，在多线程中调用属性可能会发生线程锁的问题，不过苹果声明，在iOS上不必考虑这个问题，缺点是会影响性能。 getter vs setter可以用来指定getter和setter的方法名，常用于BOOL中 如有错误，欢迎指正]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[指针变量的写法]]></title>
      <url>2016%2F11%2F23%2F17.%20%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%99%E6%B3%95%2F</url>
      <content type="text"><![CDATA[指针变量的写法在刚学习C语言的时候，我对于指针很畏惧，很大程度上是因为它那个恶心的*，后来接触到了以后，发现确实挺恶心的 关于指针变量的写法不外乎这几种 int *foo;int * foo;int* foo; 第一种最流行，它写在了变量名前面，能够很清晰的表明这是个指针变量，但我觉得也有问题，为什么？先举个例子 int a = 0;foo = &amp;a;*foo = 100; 注意到了吗？ 在使用指针变量的时候，我们不会把那个*再写出来了，反而，如果你写出来的话，代表的意思就不是指针变量了，而是指针变量所指向变量。 如果我写了 int *foo;foo = &amp;a; 我会感觉到这样的代码，让我有一点歧义，明明上面的foo变量在声明时带上了*表明它是一个指针变量，而下面的带上了就成了另外一种意思，所以我有点讨厌这样的写法。 第二种写法，很清晰，但也很分散，这样的代码估计很少有人写，另外也有一点歧义，太像乘*了 第三种写法，直接写在类型的后面，写的人比第二种多一些，我觉得不错，避免了第一种的歧义。 不管你怎么写，在实际当中肯定还是要遵守团队的规范]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS界面开发（基础篇）主观题考试]]></title>
      <url>2016%2F11%2F21%2F16.%20iOS%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%E4%B8%BB%E8%A7%82%E9%A2%98%E8%80%83%E8%AF%95%2F</url>
      <content type="text"><![CDATA[iOS界面开发（基础篇）主观题考试 要求： 使用导航栏和UITableViewController构造一个和上面截图基本类似界面 界面只要求布局方位一致即可，不要求位置间距完全一致。每个商品Cell的 粉色字体 部分（限时购、特价、限购X件），不需要实现，也不用占位置 ​ 导航栏中间Title为 购物车（商品种类数量），例如上图是三类商品，那就是 购物车(3)，如果删除了一个商品，需要同步变成 购物车(2) 导航栏右侧的编辑和图标，可以不响应动作，但是需要显示出来 购物车里面的所有商品按照仓库分组，也就是说数据结构是： [ 仓库1 : [商品1, 商品2, …], 仓库2 : [商品1, 商品2, 商品3, …] ] 每个仓库的Section由：仓库名称、商品列表、仓库结算信息组成 仓库名称左侧选择按钮： a. 点击选中，该Section下的所有商品列表需要选中 b. 取消选中，该Section下的所有商品列表需要取消选中 c. 如果该Section下的所有商品列表只有部分选中，其应该为未选中： 仓库结算信息，只需要包括 本仓总计（不含税）** **这一项，该项的数值是：该Section下的被选中的商品列表价格之和；其他结算信息项不用实现。 仓库和仓库Section间需要有大约10dp的灰色间隔 每个商品Cell需要支持右侧的滑动删除： 当点击删除时，该商品需要被删除，导航栏的数目、仓库的左侧选中状态、仓库结算信息需要更新。 税费点击展开，其中点击展开需要有高度变化动画（效果参考考拉海购APP）： 每个商品的文字描述最多为两行，超过显示… 。 这里要求实现：a. 一行商品标题显示效果 b. 商品标题过长导致两行并跟随… 的显示效果。 每个商品Cell需要执行左侧的选择框的选中和取消选中，选中状态改变时，仓库的左侧选中状态、仓库结算信息需要更新。 整个页面底部的全部结算界面，其展示信息不需要变化，固定写死即可，也不用响应动作；只需要固定悬浮在屏幕的底部，不随滚动条滚动。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫四周课程]]></title>
      <url>2016%2F11%2F21%2F15.%20Python%E7%88%AC%E8%99%AB%E5%9B%9B%E5%91%A8%E8%AF%BE%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Python爬虫四周课程 课程相关 答疑时间: 14:00 - 17:00 直播时间: 另行通知 其他 课程简介: 爬、存、查、现 爬虫 分为定向和非定向(Google、Baidu) 我们爬取的是指定网站的爬虫， 我们只需要使用一个数据库存储，百度是分层集群存储 哈希表存储线性结构 爬虫 = 数据请求(HTTP) + 数据解析(html/json) Debug:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[让你的 alfred 支持拼音搜索]]></title>
      <url>2016%2F11%2F13%2F14.%20%E8%AE%A9%E4%BD%A0%E7%9A%84alfred%E6%94%AF%E6%8C%81%E6%8B%BC%E9%9F%B3%E6%90%9C%E7%B4%A2%2F</url>
      <content type="text"><![CDATA[让你的 Alfred 支持拼音搜索来源：https://gist.github.com/tiann/35fb758c18036d7f8640 | https://www.v2ex.com/t/248284 安装 pypinyin 这个库（可能需要sudo） pip install pypinyin 执行alfred-pinyin.py python Path/filename.py#python为命令名称，这里是python2， 后面的是文件的路径和名称 下载地址 https://gist.github.com/tiann/35fb758c18036d7f8640]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[西单大悦城Apple Store体验]]></title>
      <url>2016%2F11%2F12%2F13.%20%E8%A5%BF%E5%8D%95%E5%A4%A7%E6%82%A6%E5%9F%8EApple%20Store%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[西单大悦城Apple Store体验昨天去了北京的西单，路过Apple Store，焉能不进去看看？ 懒得去周边的商场，就一直呆了很久，对几个东西有点感触： iPhone7 Bose降噪耳机 全新的MacBook Pro iPhone7玩了玩iPhone7 和 iPhone7 Plus，发现大屏的体验还是不错的，改变了我对大屏手机的看法，也看了景深人像的功能，不过觉得没那么重要，Plus的作用还是大，这样的话可以接收更多的信息。 把玩了许久iPhone7，又去体验体验iPhone6s，因为有不同，才能够更深刻的体验到变化。iPhone7的震动反馈做的更好，代替了原来单一的震动模式，增加了很多新的种类，结合着全新的Home Button，有了一个全新的反馈体验。 对于新的Home Button，总结来说，已经不是实体按键了，看来Apple也放弃了实体键，最终转向了虚拟按键，本来还不是很适应，但当我把玩了一段时间的iPhone7之后，我再去用iPhone6s时，顿时感受手更累了，想回到iPhone7上面去。 Bose降噪耳机以前就听过降噪耳机的用武之地，以前不觉得有什么，果然有些东西你不体会、不体验是不会知道的，当我戴上耳机的那一刹那，真是觉得置身事外，摘下耳机又回到了这个世界。倘若戴上这个耳机，走入地铁早高峰的洪流之中，至少耳朵是干净的。 全新的Macbook Pro没有带TouchBar的13寸的Macbook Pro，机身轻盈了不少，但13寸的好像只有2个USB-C接口，背面的ＬＯＧＯ也不亮了，这些都可以，唯一不能让人接受的就是键盘了，键盘为了配合机身，变得更薄了，但失去了触感，按下去好像没有按一样，官方声称这是第二代蝶式键盘，可我觉得和第一代没有什么改进，真是让人悲伤，或许以后会改变罢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[导航控制器的按钮设置(Storyboard)]]></title>
      <url>2016%2F11%2F11%2F12.%20%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E6%8C%89%E9%92%AE%E8%AE%BE%E7%BD%AE(Storyboard)%2F</url>
      <content type="text"><![CDATA[导航控制器的按钮设置(Storyboard)效果图: 新建UIView, 放入 ViewController 中 设置 UIView 的布局上左右都为0, 高度为44 更新Frame 放入3个 Button 到 UIView 中 设置第一个 Button 的布局, 上下左右都为0 设置第二个 Button 的布局, 右和下为0 在上一步的基础上, 设置第二个 Button 和第一个 Button 相同宽度和高度, 按住 Control 键, 拖拽第二个 Button 到第一个 Button 松手 按住 Shift 键, 选中 Equal Widths 和 Equal Heights 最后点击 Add Constraints 设置第三个 Button 的布局, 右和下为0 (同第6步) 在上一步的基础上, 设置第三个 Button 和第二个 Button 相同宽度和高度 (同第7步) 选中三个 Button 同时按下option + Command + = 更新 Frame]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[饿了么网上订餐流程]]></title>
      <url>2016%2F11%2F09%2F10.%20%E9%A5%BF%E4%BA%86%E4%B9%88%E7%BD%91%E4%B8%8A%E8%AE%A2%E9%A4%90%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[饿了么网上订餐流程毕业设计——网上订餐系统技术调研 检测地理位置（可以省略或简化，比如直接选择地点，因为后边会填写详细地点，所以这里无需深究） 选择商家（可以按照位置分类） 选择商品（每个商家的商品） 结算（计算） 选择收获地址和支付方式，填写详细信息（） 确定下单 如果在线支付转到支付页面 判断支付是否成功 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[熟悉Django的模板语言——Python第四周第二节]]></title>
      <url>2016%2F11%2F09%2F11.%20%E7%86%9F%E6%82%89Django%E7%9A%84%E6%A8%A1%E6%9D%BF%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94Python%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%AC%AC%E4%BA%8C%E8%8A%82%2F</url>
      <content type="text"><![CDATA[熟悉Django的模板语言——Python第四周第二节render()：渲染接收三个函数 request 用户点击的request x.html 我们指定模板的名称 context 上下文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python库安装]]></title>
      <url>2016%2F11%2F08%2F9.%20Python%E5%BA%93%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[Python库安装pip 一键安装库 pip3 install requests bs4 pymongo mongoengine jupy Ubuntu16.04问题 root@centos-512mb-nyc3-01:~# pip3 listTraceback (most recent call last): File &quot;/usr/bin/pip3&quot;, line 11, in &lt;module&gt; sys.exit(main()) File &quot;/usr/lib/python3/dist-packages/pip/__init__.py&quot;, line 215, in main locale.setlocale(locale.LC_ALL, &apos;&apos;) File &quot;/usr/lib/python3.5/locale.py&quot;, line 594, in setlocale return _setlocale(category, locale)locale.Error: unsupported locale setting# 换个命令试试root@centos-512mb-nyc3-01:~# python3 -m pip listTraceback (most recent call last): File &quot;/usr/lib/python3.5/runpy.py&quot;, line 184, in _run_module_as_main &quot;__main__&quot;, mod_spec) File &quot;/usr/lib/python3.5/runpy.py&quot;, line 85, in _run_code exec(code, run_globals) File &quot;/usr/lib/python3/dist-packages/pip/__main__.py&quot;, line 19, in &lt;module&gt; sys.exit(pip.main()) File &quot;/usr/lib/python3/dist-packages/pip/__init__.py&quot;, line 215, in main locale.setlocale(locale.LC_ALL, &apos;&apos;) File &quot;/usr/lib/python3.5/locale.py&quot;, line 594, in setlocale return _setlocale(category, locale)locale.Error: unsupported locale setting# 解决export LC_ALL=C Python的在线编译器 jupyter notebook命令会默认开启8888端口，会和surge起冲突 解决： jupyter notebook --port [自定义端口]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node环境介绍]]></title>
      <url>2016%2F11%2F08%2F8.%20Node%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[Node环境介绍普通的node项目环境主文件 app.js：相关的设置，包含路由的配置和一些其他重要的逻辑。这是我们开启服务后运行的。 路由：所有与页面相关的逻辑和从app.js中抽离出来的它所依赖的基础函数，比如从数据库中获取数据并将其写入HTML中 Node.js项目文件package.json：包依赖和其他元数据 node_modules中的依赖：通过package.json安装的第三方模块 数据库：一个MongoDB和元数据的实例 模板：以.jade结尾的文件 配置文件config.json：与应用安全性无关的设置，比如应用的标题 Expressnode_modules：Express.js和第三方模块的依赖都在这个目录下 views：Jade或者其他模版引擎文件 routes：包含请求处理程序的Node.js模块 db：MongoDB的种子数据和脚本 public：所有前端的静态文件，包括HTML、CSS、浏览器端的Javascript和Stylus或者其他CSS框架文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博学谷直播介绍Vue]]></title>
      <url>2016%2F11%2F03%2F7.%20%E5%8D%9A%E5%AD%A6%E8%B0%B7%E7%9B%B4%E6%92%AD%E4%BB%8B%E7%BB%8DVue.js%2F</url>
      <content type="text"><![CDATA[Vue.js 客户端Javascript框架 用于数据驱动的现代web开发 实现了MVVM思想 比如设计一个注册页面传统方式： 找到用户名的文本框，捕捉鼠标偏离的事件，判断文本框的内容进行是否存在的校验 问题： 界面代码重复使用率低 需要的变化大部分是在界面上，而 应用程序的基本逻辑：把数据放到界面上显示 理想状态，界面和数据独立 结论：用数据驱动界面，把界面放置到最后 var app = new Vue(&#123; //业务逻辑抽象 data: &#123; username: &apos;&apos;, email: &apos;&apos;, &#125;&#125;) 如何使用Vue.jsSublime Vue作者建议学习顺序从基础着手 通读javascript基础 操作步骤 找出来页面最核心组成，用数据的方式描述 ​ 根据设计的结构完成ViewModel的编写 ​ &lt;intput class = ""]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ubuntu开启root——以腾讯云为例]]></title>
      <url>2016%2F11%2F03%2F6.%20Ubuntu%E5%BC%80%E5%90%AFroot%E2%80%94%E2%80%94%E4%BB%A5%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B8%BA%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[Ubuntu默认没有启用root账户，这有利于安全，但在实际操作中，我们常常需要访问一些需要root权限才可以访问的目录，需要启动root账户 操作步骤 登陆服务器 ssh ubuntu@yoursiteIP 修改root密码 sudo passwd root 修改ssh配置 sudo vi /etc/ssh/sshd_config 找到 PermitRootLogin 这项 将其改为 yes 退出并重启ssh服务 sudo service ssh restart ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm install速度慢的解决方法]]></title>
      <url>2016%2F11%2F02%2F5.%20npm%20install%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在使用npm安装的时候经常遇到npm install速度慢的情况，这是因为我们的网络和npm的服务器相隔较远，延迟很大造成的，怎么解决呢？ 使用taobao镜像有两种方式，本文中的所有代码都需要在终端中输入 一、在命令后面加参数npm install --registry=https://registry.npm.taobao.org 这代表了我们可以从taobao的服务器中来获取，就解决了速度慢的问题。 二、使用cnpm使用cnpm的目的是可以一劳永逸的代替npm命令，这样的话就方便多了 安装cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org 验证一下当发现输入命令之后，后面的网址是taobao的时候就说明已经成功了 使用taobao镜像的缺点： 不能使用publish命令 和npm官方镜像源有10分钟的延迟]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[将购买的域名配置到github pages中]]></title>
      <url>2016%2F11%2F01%2F4.%20%E5%B0%86%E8%B4%AD%E4%B9%B0%E7%9A%84%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%88%B0github%20pages%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[参考 : https://help.github.com/articles/setting-up-an-apex-domain/ 在yourname.github.io的Setting中添加你的自定义域名 在域名解析中添加相应的DNS 103.245.222.133 Github pages设置301重定向购买了域名之后，我们想要让不带www的网址重定向到带www前缀的网址上面 在yourname.github.io目录下新建CNAME文件，内容是你的自定义域名比如www.magaofei.com 在域名解析那里，添加CNAME类型的记录，值为yourname.github.io macOS下查看端口和杀掉端口 Find out the process ID (PID) which is occupying the port number (e.g., 5955) you would like to free sudo lsof -i :5955 Kill the process which is currently using the port using its PID sudo kill -9 PID ##]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[配置环境]]></title>
      <url>2016%2F11%2F01%2F3.%20%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[配置环境使用hexo搭建来自NexT的主题 教程来自http://xiaolai.li/ note： 命令出错可能是前面没有加上sudo 每次只需要把.md文件丢到source目录下，再运行hexo g和hexo d就可以 主题配置网站http://theme-next.iissnan.com/theme-settings.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试]]></title>
      <url>2016%2F11%2F01%2F2.%202.4%20%E4%B8%80%E6%97%A6%E5%8F%91%E7%8E%B0%E9%9C%80%E8%A6%81%E9%87%8D%E5%A4%8D%E7%9A%84%E5%B7%A5%E4%BD%9C%E2%80%A6%E2%80%A6%2F</url>
      <content type="text"><![CDATA[测试 然后就可以在 Terminal 面板中用 hexo generate生成静态 html 文件，用 hexo server本地查看（在浏览器中用这个地址：localhost:4000），或用 hexo deploy 发布到 yourname.github.io 上去…… 以后你想发表博客文章的时候，无非就是在 source 目录中创建新的 .md 文件，而后 hexo generate，之后再 hexo deploy. 2.4 一旦发现需要重复的工作……—— 就要马上想办法要么 1)自动化，要么 2) 减少工作量。这是工程师的思考行动方式，在工程师的世界里，懒惰有另外一种用处，是积极的用处：它是用来刺激寻找提高效率的手段。普通人懒起来就什么都不干了；工程师懒起来就使劲琢磨： “怎么做才能将来不用做或者起码少做却可以实际上干更多呢？” 注意：“实际上干更多”才是重点！ 反复地敲 hexo generate、hexo server、hexo deploy 好累啊！怎么办？我们可以给命令行里反复输入的命令编制缩写…… 命令行下输入，其实就是用 Atom 打开 ~/.aliases 文件： atom ~/.aliases 在该文件下输入以下内容： alias hgs=&quot;hexo g&amp;&amp;hexo s&quot;alias hgd=&quot;hexo g&amp;&amp;hexo d&quot; 重新启动 Terminal 之后，只要输入 hgs 就是生成内容之后在 localhost:4000 里预览，输入 hgd 就是部署到服务器上……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>2016%2F11%2F01%2F1.%20hello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
